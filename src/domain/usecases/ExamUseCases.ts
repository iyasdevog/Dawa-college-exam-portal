import { Exam, SupplementaryExam } from '../entities/Exam';
import { SubjectMarks } from '../entities/Student';
import { IExamRepository } from '../interfaces/IExamRepository';
import { IStudentRepository } from '../interfaces/IStudentRepository';
import { ISubjectRepository } from '../interfaces/ISubjectRepository';

export class ExamUseCases {
    constructor(
        private examRepository: IExamRepository,
        private studentRepository: IStudentRepository,
        private subjectRepository: ISubjectRepository
    ) { }

    async createSupplementaryExam(data: {
        studentId: string;
        subjectId: string;
        originalSemester: 'Odd' | 'Even';
        originalYear: number;
        supplementaryYear: number;
    }): Promise<string> {
        // Validate student exists
        const student = await this.studentRepository.findById(data.studentId);
        if (!student) {
            throw new Error('Student not found');
        }

        // Validate subject exists
        const subject = await this.subjectRepository.findById(data.subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        // Check if student failed the original exam
        const studentMarks = student.marks[data.subjectId];
        if (!studentMarks || studentMarks.status !== 'Failed') {
            throw new Error('Student must have failed the original exam to be eligible for supplementary');
        }

        // Check if supplementary exam already exists
        const existingSupplementary = await this.examRepository.findSupplementaryByStudent(data.studentId);
        const duplicateExam = existingSupplementary.find(exam =>
            exam.subjectId === data.subjectId &&
            exam.supplementaryYear === data.supplementaryYear
        );

        if (duplicateExam) {
            throw new Error('Supplementary exam already exists for this student and subject');
        }

        const supplementaryExam = SupplementaryExam.create({
            id: '', // Will be generated by repository
            ...data,
            semester: data.originalSemester,
            year: data.supplementaryYear,
            status: 'Pending'
        });

        return await this.examRepository.saveSupplementary(supplementaryExam);
    }

    async updateSupplementaryExamMarks(
        examId: string,
        ta: number,
        ce: number
    ): Promise<void> {
        const exam = await this.examRepository.findById(examId);
        if (!exam || !exam.isSupplementary) {
            throw new Error('Supplementary exam not found');
        }

        const subject = await this.subjectRepository.findById(exam.subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        // Validate marks against subject limits
        if (ta > subject.maxTA || ce > subject.maxCE) {
            throw new Error(`Marks exceed maximum allowed (TA: ${subject.maxTA}, CE: ${subject.maxCE})`);
        }

        const total = ta + ce;
        const status = subject.isPassingScore(ta, ce) ? 'Passed' : 'Failed';

        const marks: SubjectMarks = {
            ta,
            ce,
            total,
            status,
            isSupplementary: true,
            supplementaryYear: exam.year
        };

        await this.examRepository.updateSupplementaryMarks(examId, marks);

        // If passed, update the student's main record
        if (status === 'Passed') {
            await this.studentRepository.updateStudentMarks(exam.studentId, exam.subjectId, marks);

            // Recalculate rankings
            const student = await this.studentRepository.findById(exam.studentId);
            if (student) {
                await this.studentRepository.calculateClassRankings(student.className);
            }
        }
    }

    async getSupplementaryExamsByStudent(studentId: string): Promise<SupplementaryExam[]> {
        return await this.examRepository.findSupplementaryByStudent(studentId);
    }

    async getSupplementaryExamsBySubject(subjectId: string, year?: number): Promise<SupplementaryExam[]> {
        return await this.examRepository.findSupplementaryBySubject(subjectId, year);
    }

    async getPendingSupplementaryExams(): Promise<SupplementaryExam[]> {
        const allExams = await this.examRepository.findSupplementaryBySubject(''); // Get all
        return allExams.filter(exam => exam.status === 'Pending');
    }

    async getCompletedSupplementaryExams(year?: number): Promise<SupplementaryExam[]> {
        const allExams = await this.examRepository.findSupplementaryBySubject(''); // Get all
        return allExams.filter(exam =>
            exam.status === 'Completed' &&
            (!year || exam.supplementaryYear === year)
        );
    }

    async deleteSupplementaryExam(examId: string): Promise<void> {
        const exam = await this.examRepository.findById(examId);
        if (!exam || !exam.isSupplementary) {
            throw new Error('Supplementary exam not found');
        }

        await this.examRepository.deleteSupplementary(examId);
    }

    async getStudentsEligibleForSupplementary(
        subjectId: string,
        semester: 'Odd' | 'Even',
        year: number
    ): Promise<{ studentId: string; studentName: string; failedMarks: SubjectMarks }[]> {
        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        const enrolledStudentIds = await this.getEnrolledStudents(subjectId);
        const students = await Promise.all(
            enrolledStudentIds.map(id => this.studentRepository.findById(id))
        );

        const eligibleStudents = students
            .filter((student): student is NonNullable<typeof student> => student !== null)
            .filter(student =>
                student.semester === semester &&
                student.marks[subjectId] &&
                student.marks[subjectId].status === 'Failed'
            )
            .map(student => ({
                studentId: student.id,
                studentName: student.name,
                failedMarks: student.marks[subjectId]
            }));

        return eligibleStudents;
    }

    private async getEnrolledStudents(subjectId: string): Promise<string[]> {
        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            return [];
        }

        if (subject.subjectType === 'general') {
            const allStudents: string[] = [];
            for (const className of subject.targetClasses) {
                const classStudents = await this.studentRepository.findByClass(className);
                allStudents.push(...classStudents.map(s => s.id));
            }
            return allStudents;
        } else {
            return await this.subjectRepository.getEnrolledStudents(subjectId);
        }
    }

    async getExamStatistics(year: number): Promise<{
        totalExams: number;
        regularExams: number;
        supplementaryExams: number;
        passedExams: number;
        failedExams: number;
        pendingExams: number;
    }> {
        const allExams = await this.examRepository.findSupplementaryBySubject(''); // Get all supplementary
        const yearExams = allExams.filter(exam => exam.supplementaryYear === year);

        const passedCount = yearExams.filter(exam => exam.marks?.status === 'Passed').length;
        const failedCount = yearExams.filter(exam => exam.marks?.status === 'Failed').length;
        const pendingCount = yearExams.filter(exam => exam.status === 'Pending').length;

        return {
            totalExams: yearExams.length,
            regularExams: 0, // Would need to implement regular exam tracking
            supplementaryExams: yearExams.length,
            passedExams: passedCount,
            failedExams: failedCount,
            pendingExams: pendingCount
        };
    }
}