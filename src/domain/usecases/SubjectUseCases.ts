import { Subject } from '../entities/Subject';
import { ISubjectRepository } from '../interfaces/ISubjectRepository';
import { IStudentRepository } from '../interfaces/IStudentRepository';

export class SubjectUseCases {
    constructor(
        private subjectRepository: ISubjectRepository,
        private studentRepository: IStudentRepository
    ) { }

    async createSubject(subjectData: {
        name: string;
        arabicName?: string;
        maxTA: number;
        maxCE: number;
        passingTotal: number;
        facultyName?: string;
        targetClasses: string[];
        subjectType: 'general' | 'elective';
    }): Promise<string> {
        // Validate subject data
        if (subjectData.maxTA <= 0 || subjectData.maxCE <= 0) {
            throw new Error('Maximum marks must be greater than 0');
        }

        if (subjectData.passingTotal > (subjectData.maxTA + subjectData.maxCE)) {
            throw new Error('Passing total cannot exceed maximum total marks');
        }

        if (subjectData.targetClasses.length === 0) {
            throw new Error('Subject must target at least one class');
        }

        const subject = Subject.create({
            id: '', // Will be generated by repository
            ...subjectData
        });

        return await this.subjectRepository.save(subject);
    }

    async getSubjectById(id: string): Promise<Subject | null> {
        return await this.subjectRepository.findById(id);
    }

    async getSubjectsByClass(className: string): Promise<Subject[]> {
        return await this.subjectRepository.findByClass(className);
    }

    async getAllSubjects(): Promise<Subject[]> {
        return await this.subjectRepository.findAll();
    }

    async updateSubject(id: string, updates: Partial<Subject>): Promise<void> {
        const subject = await this.subjectRepository.findById(id);
        if (!subject) {
            throw new Error('Subject not found');
        }

        await this.subjectRepository.update(id, updates);
    }

    async deleteSubject(id: string): Promise<void> {
        const subject = await this.subjectRepository.findById(id);
        if (!subject) {
            throw new Error('Subject not found');
        }

        // Clear all marks for this subject before deletion
        const allStudents = await this.studentRepository.findAll();
        const studentsWithMarks = allStudents.filter(student =>
            Object.keys(student.marks).includes(id)
        );

        if (studentsWithMarks.length > 0) {
            const studentIds = studentsWithMarks.map(s => s.id);
            await this.studentRepository.clearSubjectMarks(id, studentIds);
        }

        await this.subjectRepository.delete(id);
    }

    async enrollStudentInElective(subjectId: string, studentId: string): Promise<void> {
        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        if (subject.subjectType !== 'elective') {
            throw new Error('Cannot enroll students in general subjects');
        }

        const student = await this.studentRepository.findById(studentId);
        if (!student) {
            throw new Error('Student not found');
        }

        if (!subject.isApplicableToClass(student.className)) {
            throw new Error('Subject is not applicable to student\'s class');
        }

        await this.subjectRepository.enrollStudent(subjectId, studentId);
    }

    async unenrollStudentFromElective(subjectId: string, studentId: string): Promise<void> {
        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        if (subject.subjectType !== 'elective') {
            throw new Error('Cannot unenroll students from general subjects');
        }

        // Clear student's marks for this subject
        await this.studentRepository.clearStudentMarks(studentId, subjectId);

        await this.subjectRepository.unenrollStudent(subjectId, studentId);
    }

    async getEnrolledStudents(subjectId: string): Promise<string[]> {
        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        if (subject.subjectType === 'general') {
            // For general subjects, return all students from target classes
            const allStudents: string[] = [];
            for (const className of subject.targetClasses) {
                const classStudents = await this.studentRepository.findByClass(className);
                allStudents.push(...classStudents.map(s => s.id));
            }
            return allStudents;
        } else {
            // For elective subjects, return only enrolled students
            return await this.subjectRepository.getEnrolledStudents(subjectId);
        }
    }

    async getSubjectStatistics(subjectId: string): Promise<{
        totalStudents: number;
        passedStudents: number;
        failedStudents: number;
        averageScore: number;
        highestScore: number;
        lowestScore: number;
    }> {
        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        const enrolledStudentIds = await this.getEnrolledStudents(subjectId);
        const students = await Promise.all(
            enrolledStudentIds.map(id => this.studentRepository.findById(id))
        );

        const studentsWithMarks = students
            .filter((student): student is NonNullable<typeof student> => student !== null)
            .filter(student => student.marks[subjectId]);

        if (studentsWithMarks.length === 0) {
            return {
                totalStudents: enrolledStudentIds.length,
                passedStudents: 0,
                failedStudents: 0,
                averageScore: 0,
                highestScore: 0,
                lowestScore: 0
            };
        }

        const marks = studentsWithMarks.map(student => student.marks[subjectId]);
        const passedCount = marks.filter(mark => mark.status === 'Passed').length;
        const scores = marks.map(mark => mark.total);
        const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;

        return {
            totalStudents: enrolledStudentIds.length,
            passedStudents: passedCount,
            failedStudents: marks.length - passedCount,
            averageScore: Math.round(averageScore * 100) / 100,
            highestScore: Math.max(...scores),
            lowestScore: Math.min(...scores)
        };
    }
}