import { Student, SubjectMarks } from '../entities/Student';
import { IStudentRepository } from '../interfaces/IStudentRepository';
import { ISubjectRepository } from '../interfaces/ISubjectRepository';

export class StudentUseCases {
    constructor(
        private studentRepository: IStudentRepository,
        private subjectRepository: ISubjectRepository
    ) { }

    async createStudent(studentData: {
        adNo: string;
        name: string;
        className: string;
        semester: 'Odd' | 'Even';
    }): Promise<string> {
        // Validate admission number uniqueness
        const existingStudent = await this.studentRepository.findByAdmissionNumber(studentData.adNo);
        if (existingStudent) {
            throw new Error(`Student with admission number ${studentData.adNo} already exists`);
        }

        const student = Student.create({
            id: '', // Will be generated by repository
            ...studentData
        });

        return await this.studentRepository.save(student);
    }

    async getStudentById(id: string): Promise<Student | null> {
        return await this.studentRepository.findById(id);
    }

    async getStudentByAdmissionNumber(adNo: string): Promise<Student | null> {
        return await this.studentRepository.findByAdmissionNumber(adNo);
    }

    async getStudentsByClass(className: string): Promise<Student[]> {
        return await this.studentRepository.findByClass(className);
    }

    async getAllStudents(): Promise<Student[]> {
        return await this.studentRepository.findAll();
    }

    async updateStudentMarks(
        studentId: string,
        subjectId: string,
        ta: number,
        ce: number
    ): Promise<void> {
        const student = await this.studentRepository.findById(studentId);
        if (!student) {
            throw new Error('Student not found');
        }

        const subject = await this.subjectRepository.findById(subjectId);
        if (!subject) {
            throw new Error('Subject not found');
        }

        // Validate marks against subject limits
        if (ta > subject.maxTA || ce > subject.maxCE) {
            throw new Error(`Marks exceed maximum allowed (TA: ${subject.maxTA}, CE: ${subject.maxCE})`);
        }

        const total = ta + ce;
        const status = subject.isPassingScore(ta, ce) ? 'Passed' : 'Failed';

        const marks: SubjectMarks = {
            ta,
            ce,
            total,
            status
        };

        await this.studentRepository.updateStudentMarks(studentId, subjectId, marks);
        await this.studentRepository.calculateClassRankings(student.className);
    }

    async deleteStudent(id: string): Promise<void> {
        const student = await this.studentRepository.findById(id);
        if (!student) {
            throw new Error('Student not found');
        }

        await this.studentRepository.delete(id);
        await this.studentRepository.calculateClassRankings(student.className);
    }

    async bulkImportStudents(
        studentsData: Array<{
            adNo: string;
            name: string;
            className: string;
            semester: 'Odd' | 'Even';
        }>
    ): Promise<{ success: number; errors: string[] }> {
        const students = studentsData.map(data => Student.create({
            id: '', // Will be generated by repository
            ...data
        }));

        const result = await this.studentRepository.bulkImport(students);

        // Recalculate rankings for all affected classes
        const affectedClasses = [...new Set(studentsData.map(s => s.className))];
        for (const className of affectedClasses) {
            await this.studentRepository.calculateClassRankings(className);
        }

        return result;
    }

    async clearStudentMarks(studentId: string, subjectId: string): Promise<void> {
        const student = await this.studentRepository.findById(studentId);
        if (!student) {
            throw new Error('Student not found');
        }

        await this.studentRepository.clearStudentMarks(studentId, subjectId);
        await this.studentRepository.calculateClassRankings(student.className);
    }

    async getClassRankings(className: string): Promise<Student[]> {
        const students = await this.studentRepository.findByClass(className);
        return students.sort((a, b) => a.rank - b.rank);
    }

    async getTopPerformers(limit: number = 10): Promise<Student[]> {
        const students = await this.studentRepository.findAll();
        return students
            .filter(s => s.grandTotal > 0)
            .sort((a, b) => b.average - a.average)
            .slice(0, limit);
    }

    async getStudentsNeedingSupplementary(): Promise<Student[]> {
        const students = await this.studentRepository.findAll();
        return students.filter(student => {
            const failedSubjects = student.getFailedSubjects();
            return failedSubjects.length > 0;
        });
    }
}