import { test, expect } from '@playwright/test';

test.describe('Security Vulnerability Tests', () => {
    test.beforeEach(async ({ page }) => {
        await page.goto('/');
    });

    test('should not expose sensitive information in client-side code', async ({ page }) => {
        // Check for hardcoded credentials in JavaScript
        const scripts = await page.locator('script').all();

        for (const script of scripts) {
            const scriptContent = await script.textContent();
            if (scriptContent) {
                // Check for common patterns of exposed credentials
                expect(scriptContent).not.toMatch(/password\s*[:=]\s*['"][^'"]+['"]/i);
                expect(scriptContent).not.toMatch(/api[_-]?key\s*[:=]\s*['"][^'"]+['"]/i);
                expect(scriptContent).not.toMatch(/secret\s*[:=]\s*['"][^'"]+['"]/i);
                expect(scriptContent).not.toMatch(/token\s*[:=]\s*['"][^'"]+['"]/i);

                // Check for specific hardcoded values that shouldn't be exposed
                expect(scriptContent).not.toContain('admin');
                expect(scriptContent).not.toContain('1234');
            }
        }

        // Check network requests for exposed credentials
        const responses: string[] = [];
        page.on('response', async (response) => {
            try {
                const text = await response.text();
                responses.push(text);
            } catch (e) {
                // Some responses may not be readable
            }
        });

        await page.reload();
        await page.waitForLoadState('networkidle');

        // Check responses don't contain sensitive data
        responses.forEach(responseText => {
            expect(responseText).not.toMatch(/password\s*[:=]\s*['"][^'"]+['"]/i);
            expect(responseText).not.toMatch(/api[_-]?key\s*[:=]\s*['"][^'"]+['"]/i);
        });
    });

    test('should implement proper Content Security Policy', async ({ page }) => {
        const response = await page.goto('/');
        const headers = response?.headers() || {};

        // Check for CSP header
        const csp = headers['content-security-policy'] || headers['content-security-policy-report-only'];

        if (csp) {
            // Should have restrictive CSP
            expect(csp).toContain("default-src 'self'");
            expect(csp).not.toContain("'unsafe-eval'");
            expect(csp).not.toContain("'unsafe-inline'");
        }
    });

    test('should have proper security headers', async ({ page }) => {
        const response = await page.goto('/');
        const headers = response?.headers() || {};

        // Check for security headers
        expect(headers['x-frame-options'] || headers['x-frame-options']).toBeTruthy();
        expect(headers['x-content-type-options']).toBe('nosniff');

        // Check for HSTS in production
        if (page.url().startsWith('https://')) {
            expect(headers['strict-transport-security']).toBeTruthy();
        }
    });

    test('should validate input sanitization', async ({ page }) => {
        await page.click('text=Public Portal');

        const searchInput = page.locator('input[placeholder*="admission"]');

        // Test XSS prevention
        const xssPayloads = [
            '<script>alert("xss")</script>',
            'javascript:alert("xss")',
            '<img src="x" onerror="alert(\'xss\')">',
            '"><script>alert("xss")</script>',
            '\';alert("xss");//'
        ];

        for (const payload of xssPayloads) {
            await searchInput.fill(payload);
            await page.click('button:has-text("Search")');

            // Wait for any potential script execution
            await page.waitForTimeout(1000);

            // Check that no alert was triggered (XSS prevented)
            const dialogs: string[] = [];
            page.on('dialog', dialog => {
                dialogs.push(dialog.message());
                dialog.dismiss();
            });

            expect(dialogs.length).toBe(0);

            // Check that the payload is properly escaped in the DOM
            const pageContent = await page.content();
            expect(pageContent).not.toContain('<script>alert("xss")</script>');
        }
    });

    test('should prevent SQL injection attempts', async ({ page }) => {
        await page.click('text=Public Portal');

        const searchInput = page.locator('input[placeholder*="admission"]');

        // Test SQL injection payloads
        const sqlPayloads = [
            "'; DROP TABLE students; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "admin'--",
            "' OR 1=1 --"
        ];

        for (const payload of sqlPayloads) {
            await searchInput.fill(payload);
            await page.click('button:has-text("Search")');

            await page.waitForTimeout(1000);

            // Should not return unexpected data or cause errors
            const errorMessages = await page.locator('text=error, text=Error, text=SQL, text=database').count();
            expect(errorMessages).toBe(0);
        }
    });

    test('should implement proper authentication security', async ({ page }) => {
        // Test admin login security
        const adminButton = page.locator('text=Admin Login, text=Faculty Entry, button:has-text("Admin")');
        if (await adminButton.count() > 0) {
            await adminButton.first().click();

            // Test brute force protection (multiple failed attempts)
            const passwordInput = page.locator('input[type="password"], input[placeholder*="password"]');
            const loginButton = page.locator('button:has-text("Login"), button:has-text("Enter")');

            for (let i = 0; i < 5; i++) {
                await passwordInput.fill('wrongpassword');
                await loginButton.click();
                await page.waitForTimeout(500);
            }

            // Should implement some form of rate limiting or account lockout
            const errorMessage = await page.locator('text=locked, text=attempts, text=wait, text=blocked').count();
            // Note: This test may pass even without rate limiting, but it checks for the presence of such measures
        }
    });

    test('should protect against CSRF attacks', async ({ page }) => {
        // Login as admin
        const adminButton = page.locator('text=Admin Login, text=Faculty Entry, button:has-text("Admin")');
        if (await adminButton.count() > 0) {
            await adminButton.first().click();
            await page.fill('input[type="password"], input[placeholder*="password"]', '1234');
            await page.click('button:has-text("Login"), button:has-text("Enter")');

            // Check for CSRF tokens in forms
            const forms = await page.locator('form').all();

            for (const form of forms) {
                const csrfToken = await form.locator('input[name*="csrf"], input[name*="token"], input[type="hidden"]').count();
                const formAction = await form.getAttribute('action');

                // Forms that modify data should have CSRF protection
                if (formAction && (formAction.includes('POST') || formAction.includes('PUT') || formAction.includes('DELETE'))) {
                    expect(csrfToken).toBeGreaterThan(0);
                }
            }
        }
    });

    test('should implement secure session management', async ({ page, context }) => {
        // Login as admin
        const adminButton = page.locator('text=Admin Login, text=Faculty Entry, button:has-text("Admin")');
        if (await adminButton.count() > 0) {
            await adminButton.first().click();
            await page.fill('input[type="password"], input[placeholder*="password"]', '1234');
            await page.click('button:has-text("Login"), button:has-text("Enter")');

            // Check cookies for security attributes
            const cookies = await context.cookies();

            cookies.forEach(cookie => {
                if (cookie.name.toLowerCase().includes('session') ||
                    cookie.name.toLowerCase().includes('auth') ||
                    cookie.name.toLowerCase().includes('token')) {

                    // Session cookies should be secure
                    if (page.url().startsWith('https://')) {
                        expect(cookie.secure).toBe(true);
                    }

                    // Should be HttpOnly to prevent XSS
                    expect(cookie.httpOnly).toBe(true);

                    // Should have SameSite attribute
                    expect(['Strict', 'Lax', 'None']).toContain(cookie.sameSite);
                }
            });
        }
    });

    test('should prevent information disclosure', async ({ page }) => {
        // Test for information disclosure in error messages
        await page.click('text=Public Portal');

        // Try to access non-existent resources
        const testUrls = [
            '/admin',
            '/config',
            '/debug',
            '/test',
            '/.env',
            '/package.json'
        ];

        for (const testUrl of testUrls) {
            const response = await page.goto(testUrl, { waitUntil: 'networkidle' });

            if (response) {
                const content = await page.content();

                // Should not expose sensitive information in error pages
                expect(content).not.toMatch(/stack trace/i);
                expect(content).not.toMatch(/database.*error/i);
                expect(content).not.toMatch(/internal server error/i);
                expect(content).not.toMatch(/debug/i);
                expect(content).not.toContain('node_modules');
                expect(content).not.toContain('webpack');
            }
        }
    });

    test('should implement proper access controls', async ({ page }) => {
        // Test that admin functions are not accessible without authentication
        const adminUrls = [
            '/faculty-entry',
            '/management',
            '/admin-dashboard'
        ];

        for (const adminUrl of adminUrls) {
            await page.goto(adminUrl);

            // Should redirect to login or show access denied
            const currentUrl = page.url();
            const pageContent = await page.content();

            expect(
                currentUrl.includes('login') ||
                pageContent.includes('login') ||
                pageContent.includes('unauthorized') ||
                pageContent.includes('access denied')
            ).toBeTruthy();
        }
    });

    test('should validate file upload security', async ({ page }) => {
        // Login as admin
        const adminButton = page.locator('text=Admin Login, text=Faculty Entry, button:has-text("Admin")');
        if (await adminButton.count() > 0) {
            await adminButton.first().click();
            await page.fill('input[type="password"], input[placeholder*="password"]', '1234');
            await page.click('button:has-text("Login"), button:has-text("Enter")');

            // Look for file upload functionality
            const fileInputs = await page.locator('input[type="file"]').all();

            for (const fileInput of fileInputs) {
                const accept = await fileInput.getAttribute('accept');

                // File inputs should have accept attribute to restrict file types
                expect(accept).toBeTruthy();

                // Should not accept executable files
                if (accept) {
                    expect(accept).not.toContain('.exe');
                    expect(accept).not.toContain('.bat');
                    expect(accept).not.toContain('.sh');
                    expect(accept).not.toContain('.php');
                    expect(accept).not.toContain('.jsp');
                }
            }
        }
    });

    test('should implement proper data validation', async ({ page }) => {
        // Login as admin and test marks entry
        const adminButton = page.locator('text=Admin Login, text=Faculty Entry, button:has-text("Admin")');
        if (await adminButton.count() > 0) {
            await adminButton.first().click();
            await page.fill('input[type="password"], input[placeholder*="password"]', '1234');
            await page.click('button:has-text("Login"), button:has-text("Enter")');

            await page.click('text=Faculty Entry');

            // Test input validation for marks
            const numberInputs = await page.locator('input[type="number"], input[name*="mark"], input[name*="score"]').all();

            for (const input of numberInputs) {
                // Test negative values
                await input.fill('-10');
                const value = await input.inputValue();

                // Should not accept negative values for marks
                expect(parseInt(value) >= 0 || value === '').toBeTruthy();

                // Test extremely large values
                await input.fill('99999');
                await page.keyboard.press('Tab'); // Trigger validation

                // Should validate maximum values
                const validatedValue = await input.inputValue();
                expect(parseInt(validatedValue) <= 100 || validatedValue === '').toBeTruthy();
            }
        }
    });
});